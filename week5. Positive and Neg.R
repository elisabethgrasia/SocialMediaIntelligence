# Positive and Negative Relationship
# 4th April 2022


# STRUCTURAL BALANCE

library("igraph")
n = 10
X = 1:n
# randomly choose six nodes for the first group and four for the second
pos = sample(1:n, 6)
A = X[pos]
B = X[-pos]
g = make_full_graph(n)

M = -as_adjacency_matrix(g) ## set all edges as negative
M[A, A] = 1 ## set all edges between nodes from set A as positive
M[B, B] = 1 ## set all edges between nodes from set B as positive


# Now that we have our balanced graph, we can visualise the two groups using hierarchical clustering.
D = as.matrix(1 - M) ## create a matrix of distances
image(D) ## visualise the distances
?make_full_graph

## Notice the block structure
h = hclust(as.dist(D), method = "single")
image(D[h$order, h$order])   # forming a block instead of graph

####### Pick set of three nodes & changing the sign
threenodes = M[1:3, 1:3]
M[1, 2] = 1
M[2, 1] = 1
print(M)

# We can now restore M by rerunning
M = -as_adjacency_matrix(g) ## set all edges as negative
M[A, A] = 1 ## set all edges between nodes from set A as positive
M[B, B] = 1 ## set all edges between nodes from set B as positive

####### Pick a set of three nodes and change the sign of the edges to introduce a (-,-,-) triangle, 
####### making the graph a weakly balanced network. Recompute the clustering and visualise the results.
####### Were the results as expected? If not, what could have gone wrong?

M[1,3] = -1
M[3,1] = -1
print(M)

D = as.matrix(1 - M) ## create a matrix of distances
image(D) ## visualise the distances


## Notice the block structure
h = hclust(as.dist(D), method = "single")
image(D[h$order, h$order])   # forming a block instead of graph




# COUNTING SIGNED RELATIONSHIP
positiveEdgeCount = function(M) {
  ## Compute the number of positive edges for each set of three nodes. M is an
  ## adjacency matrix (symmetric) containing only +1 and -1.
  n = nrow(M)
  p = choose(n, 3)
  counter = 0
  for (a in 1:(n - 2)) {
    for (b in (a + 1):(n - 1)) {
      for (d in (b + 1):n) {
        counter = counter + 1
        m = M[c(a, b, d), c(a, b, d)]
        p[counter] = posEdges(m)
      }
    }
  }
  return(p)
}

posEdges= function(m){
  pos_count=0
  if (m[1,2]>0){
    pos_count=pos_count+1
  }
  if (m[3,2]>0){
    pos_count=pos_count+1
  }
  if (m[3,1]>0){
    pos_count=pos_count+1
  }  
  return(pos_count)
}

# resetting the M
M = -as_adjacency_matrix(g) ## set all edges as negative
M[A, A] = 1 ## set all edges between nodes from set A as positive
M[B, B] = 1 ## set all edges between nodes from set B as positive

positiveEdgeCount(M)
# to count each connectivity 
table(positiveEdgeCount(M))

######### Examine how many triangles changed by computing the number of each of the 
######### four triangle types before and after changing the edge sign.

# changing sign again
M[1,3] = -1
M[3,1] = -1
print(M)
table(positiveEdgeCount(M))


# STRUCTURAL BALANCE IN GENERAL NETWORKS
f = erdos.renyi.game(n, 0.6)
M = as_adjacency_matrix(f)
M[A, B] = -1 * M[A, B]
M[B, A] = -1 * M[B, A]
D = as.matrix(1 - M)
image(D)

# orange means the incomplete graph (ga connect)
############## Examine the block image generated by hclust
############## The function that we wrote posEdges assumes that every three nodes forms a triangle, 
############## but now that we have an incomplete graph, that assumption is not valid. 
############## Modify the function posEdges to return NA when the given three 
############## nodes donâ€™t form a triangle. Modify the graph to allow weak structural balance and 
############## examine if hclust is able to find the clusters of friends in this weakly balanced incomplete network

?hclust
